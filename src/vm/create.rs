//! VM Creation Logic
//!
//! This module handles creating new VMs: directory creation, disk image
//! generation, and launch script generation.

use anyhow::{bail, Context, Result};
use std::fs;
use std::path::{Path, PathBuf};

use crate::app::{CreateWizardState, WizardQemuConfig};
use crate::commands::qemu_img;

/// Known OVMF firmware paths across different Linux distributions
const OVMF_SEARCH_PATHS: &[&str] = &[
    // Arch Linux (current naming with .4m suffix for 4MB variant)
    "/usr/share/edk2/x64/OVMF_CODE.4m.fd",
    "/usr/share/edk2-ovmf/x64/OVMF_CODE.4m.fd",
    "/usr/share/OVMF/x64/OVMF_CODE.4m.fd",
    "/usr/share/ovmf/x64/OVMF_CODE.4m.fd",
    // Arch Linux (legacy naming without .4m)
    "/usr/share/edk2-ovmf/x64/OVMF_CODE.fd",
    "/usr/share/edk2/x64/OVMF_CODE.fd",
    // Debian/Ubuntu
    "/usr/share/OVMF/OVMF_CODE.fd",
    "/usr/share/OVMF/OVMF_CODE_4M.fd",
    // Fedora/RHEL/CentOS
    "/usr/share/edk2/ovmf/OVMF_CODE.fd",
    "/usr/share/edk2/ovmf/OVMF_CODE.cc.fd",
    // openSUSE
    "/usr/share/qemu/ovmf-x86_64.bin",
    "/usr/share/qemu/ovmf-x86_64-code.bin",
    // NixOS
    "/run/libvirt/nix-ovmf/OVMF_CODE.fd",
    // Generic/fallback paths
    "/usr/share/ovmf/OVMF_CODE.fd",
    "/usr/share/qemu/OVMF_CODE.fd",
    "/usr/share/ovmf/x64/OVMF_CODE.fd",
];

/// Find the OVMF_CODE.fd firmware file by checking known paths
fn find_ovmf_code_path() -> Option<String> {
    for path in OVMF_SEARCH_PATHS {
        if Path::new(path).exists() {
            return Some(path.to_string());
        }
    }
    None
}

/// Result of creating a new VM
#[derive(Debug)]
pub struct CreatedVm {
    /// Path to the VM directory - reserved for future use
    #[allow(dead_code)]
    pub path: PathBuf,
    /// Path to the launch script
    pub launch_script: PathBuf,
    /// Path to the disk image - reserved for future use
    #[allow(dead_code)]
    pub disk_image: PathBuf,
}

/// Create a new VM from wizard state
pub fn create_vm(library_path: &Path, state: &CreateWizardState) -> Result<CreatedVm> {
    // Validate inputs
    if state.vm_name.trim().is_empty() {
        bail!("VM name cannot be empty");
    }
    if state.folder_name.is_empty() {
        bail!("Folder name cannot be empty");
    }
    if state.disk_size_gb == 0 {
        bail!("Disk size must be greater than 0");
    }

    // Create VM directory
    let vm_dir = create_vm_directory(library_path, &state.folder_name)?;

    // Create disk image
    let disk_filename = format!("{}.qcow2", state.folder_name);
    let disk_path = create_disk_image(&vm_dir, &disk_filename, state.disk_size_gb)?;

    // Generate and write launch script
    let script_content = generate_launch_script(
        &state.vm_name,
        &disk_filename,
        state.iso_path.as_deref(),
        &state.qemu_config,
    );
    let launch_script_path = write_launch_script(&vm_dir, &script_content)?;

    Ok(CreatedVm {
        path: vm_dir,
        launch_script: launch_script_path,
        disk_image: disk_path,
    })
}

/// Create the VM directory
pub fn create_vm_directory(library_path: &Path, folder_name: &str) -> Result<PathBuf> {
    let vm_dir = library_path.join(folder_name);

    if vm_dir.exists() {
        bail!("VM directory already exists: {}", vm_dir.display());
    }

    fs::create_dir_all(&vm_dir)
        .with_context(|| format!("Failed to create VM directory: {}", vm_dir.display()))?;

    Ok(vm_dir)
}

/// Create a new qcow2 disk image
pub fn create_disk_image(vm_dir: &Path, filename: &str, size_gb: u32) -> Result<PathBuf> {
    let disk_path = vm_dir.join(filename);
    let size_str = format!("{}G", size_gb);

    qemu_img::create_disk(&disk_path, &size_str)
        .with_context(|| format!("Failed to create disk image: {}", disk_path.display()))?;

    Ok(disk_path)
}

/// Generate the launch.sh script content
pub fn generate_launch_script(
    vm_name: &str,
    disk_filename: &str,
    iso_path: Option<&Path>,
    config: &WizardQemuConfig,
) -> String {
    let mut script = String::new();

    // Shebang and header
    script.push_str("#!/bin/bash\n\n");
    script.push_str(&format!("# {} VM Launch Script\n", vm_name));
    script.push_str(&format!(
        "# {} CPUs, {}MB RAM, {} graphics, {} disk interface\n",
        config.cpu_cores, config.memory_mb, config.vga, config.disk_interface
    ));
    script.push_str("# Generated by vm-curator\n\n");

    // Variables
    script.push_str("VM_DIR=\"$(dirname \"$(readlink -f \"$0\")\")\"\n");
    script.push_str(&format!("DISK=\"$VM_DIR/{}\"\n", disk_filename));

    if let Some(iso) = iso_path {
        script.push_str(&format!("ISO=\"{}\"\n", iso.display()));
    } else {
        script.push_str("ISO=\"\"\n");
    }
    script.push('\n');

    // Help function
    script.push_str("show_help() {\n");
    script.push_str("    echo \"Usage: $0 [OPTIONS]\"\n");
    script.push_str("    echo \"\"\n");
    script.push_str("    echo \"Options:\"\n");
    script.push_str("    echo \"  --install        Boot from installation media\"\n");
    script.push_str("    echo \"  --cdrom <iso>    Boot with specified ISO as CD-ROM\"\n");
    script.push_str("    echo \"  (no options)     Normal boot from hard disk\"\n");
    script.push_str("}\n\n");

    // Build the base QEMU command
    let base_cmd = build_qemu_command(config, disk_filename, false, None);
    let install_cmd = build_qemu_command(config, disk_filename, true, None);

    // Main script logic
    script.push_str("case \"$1\" in\n");
    script.push_str("    --install)\n");
    script.push_str("        if [[ -z \"$ISO\" ]] || [[ ! -f \"$ISO\" ]]; then\n");
    script.push_str("            echo \"Error: Installation ISO not found at $ISO\"\n");
    script.push_str("            echo \"Please edit this script to set the ISO path or use --cdrom\"\n");
    script.push_str("            exit 1\n");
    script.push_str("        fi\n");
    script.push_str(&format!("        echo \"Booting from installation ISO...\"\n"));
    script.push_str(&format!("        exec {}\n", install_cmd));
    script.push_str("        ;;\n");
    script.push_str("    --cdrom)\n");
    script.push_str("        if [[ -z \"$2\" ]] || [[ ! -f \"$2\" ]]; then\n");
    script.push_str("            echo \"Error: Please specify a valid ISO file\"\n");
    script.push_str("            exit 1\n");
    script.push_str("        fi\n");
    script.push_str("        echo \"Booting with CD-ROM: $2\"\n");

    // Build command for custom ISO (will substitute $2)
    let cdrom_cmd = build_qemu_command(config, disk_filename, true, Some("\"$2\""));
    script.push_str(&format!("        exec {}\n", cdrom_cmd));
    script.push_str("        ;;\n");
    script.push_str("    --help|-h)\n");
    script.push_str("        show_help\n");
    script.push_str("        exit 0\n");
    script.push_str("        ;;\n");
    script.push_str("    \"\")\n");
    script.push_str(&format!("        echo \"Booting {}...\"\n", vm_name));
    script.push_str(&format!("        exec {}\n", base_cmd));
    script.push_str("        ;;\n");
    script.push_str("    *)\n");
    script.push_str("        echo \"Unknown option: $1\"\n");
    script.push_str("        show_help\n");
    script.push_str("        exit 1\n");
    script.push_str("        ;;\n");
    script.push_str("esac\n");

    script
}

/// Build the QEMU command string
fn build_qemu_command(
    config: &WizardQemuConfig,
    _disk_filename: &str,
    with_cdrom: bool,
    custom_iso: Option<&str>,
) -> String {
    let mut args: Vec<String> = Vec::new();

    // Emulator
    args.push(config.emulator.clone());

    // KVM acceleration
    if config.enable_kvm {
        args.push("-enable-kvm".to_string());
    }

    // Machine type
    if let Some(ref machine) = config.machine {
        if config.enable_kvm {
            args.push(format!("-machine {},accel=kvm", machine));
        } else {
            args.push(format!("-machine {}", machine));
        }
    }

    // CPU
    if let Some(ref cpu_model) = config.cpu_model {
        args.push(format!("-cpu {}", cpu_model));
    }

    // SMP (CPU cores)
    args.push(format!(
        "-smp {},sockets=1,cores={},threads=1",
        config.cpu_cores, config.cpu_cores
    ));

    // Memory
    args.push(format!("-m {}M", config.memory_mb));

    // Disk
    args.push(format!(
        "-drive file=\"$DISK\",format=qcow2,if={},index=0,media=disk",
        config.disk_interface
    ));

    // CD-ROM (for install mode)
    if with_cdrom {
        let iso_ref = custom_iso.unwrap_or("\"$ISO\"");
        args.push(format!(
            "-drive file={},media=cdrom,index=1",
            iso_ref
        ));
        // Boot from CD-ROM
        args.push("-boot d".to_string());
    }

    // VGA / Graphics
    if config.gl_acceleration && config.vga == "virtio" {
        // Use virtio-vga-gl for 3D acceleration
        args.push("-device virtio-vga-gl".to_string());
    } else {
        args.push(format!("-vga {}", config.vga));
    }

    // Display (with GL if enabled)
    if config.gl_acceleration {
        args.push(format!("-display {},gl=on", config.display));
    } else {
        args.push(format!("-display {}", config.display));
    }

    // Audio backend (must be declared before devices that use it)
    if !config.audio.is_empty() {
        args.push("-audiodev pa,id=audio0".to_string());
    }

    // Audio devices
    for audio in &config.audio {
        if audio == "intel-hda" {
            args.push("-device intel-hda".to_string());
        } else if audio == "hda-duplex" || audio == "hda-output" || audio == "hda-micro" {
            // HDA codec devices must reference the audiodev
            args.push(format!("-device {},audiodev=audio0", audio));
        } else if audio == "ac97" {
            args.push("-device AC97,audiodev=audio0".to_string());
        } else if audio == "sb16" {
            args.push("-device sb16,audiodev=audio0".to_string());
        }
    }

    // Network
    if config.network_model != "none" {
        // Map short network model names to QEMU device names
        let net_device = match config.network_model.as_str() {
            "virtio" => "virtio-net-pci",
            other => other,
        };
        args.push("-netdev user,id=net0".to_string());
        args.push(format!("-device {},netdev=net0", net_device));
    }

    // USB tablet for mouse
    if config.usb_tablet {
        args.push("-usb".to_string());
        args.push("-device usb-tablet".to_string());
    }

    // RTC local time (for Windows)
    if config.rtc_localtime {
        args.push("-rtc base=localtime".to_string());
    }

    // UEFI boot
    if config.uefi {
        // Try to find OVMF firmware at common paths
        let ovmf_path = find_ovmf_code_path()
            .unwrap_or_else(|| "/usr/share/OVMF/OVMF_CODE.fd".to_string());
        args.push(format!(
            "-drive if=pflash,format=raw,readonly=on,file={}",
            ovmf_path
        ));
    }

    // TPM (if enabled, requires swtpm running)
    if config.tpm {
        args.push("-chardev socket,id=chrtpm,path=/tmp/swtpm-sock".to_string());
        args.push("-tpmdev emulator,id=tpm0,chardev=chrtpm".to_string());
        args.push("-device tpm-tis,tpmdev=tpm0".to_string());
    }

    // Extra args
    for arg in &config.extra_args {
        args.push(arg.clone());
    }

    args.join(" \\\n        ")
}

/// Write the launch script to disk and make it executable
pub fn write_launch_script(vm_dir: &Path, content: &str) -> Result<PathBuf> {
    use std::os::unix::fs::PermissionsExt;

    let script_path = vm_dir.join("launch.sh");

    fs::write(&script_path, content)
        .with_context(|| format!("Failed to write launch script: {}", script_path.display()))?;

    // Make executable (chmod +x)
    let mut perms = fs::metadata(&script_path)?.permissions();
    perms.set_mode(0o755);
    fs::set_permissions(&script_path, perms)
        .with_context(|| format!("Failed to set permissions on: {}", script_path.display()))?;

    Ok(script_path)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::app::CreateWizardState;

    #[test]
    fn test_generate_folder_name() {
        assert_eq!(CreateWizardState::generate_folder_name("Windows 10"), "windows-10");
        assert_eq!(CreateWizardState::generate_folder_name("Debian GNU/Linux"), "debian-gnu-linux");
        assert_eq!(CreateWizardState::generate_folder_name("MS-DOS 6.22"), "ms-dos-6-22");
        assert_eq!(CreateWizardState::generate_folder_name("  Spaced  Out  "), "spaced-out");
    }

    #[test]
    fn test_generate_launch_script() {
        let config = WizardQemuConfig::default();
        let script = generate_launch_script(
            "Test VM",
            "test.qcow2",
            Some(Path::new("/tmp/test.iso")),
            &config,
        );

        assert!(script.contains("#!/bin/bash"));
        assert!(script.contains("Test VM"));
        assert!(script.contains("test.qcow2"));
        assert!(script.contains("/tmp/test.iso"));
        assert!(script.contains("--install"));
        assert!(script.contains("--cdrom"));
    }

    #[test]
    fn test_build_qemu_command_basic() {
        let config = WizardQemuConfig {
            emulator: "qemu-system-x86_64".to_string(),
            memory_mb: 2048,
            cpu_cores: 2,
            cpu_model: Some("host".to_string()),
            machine: Some("q35".to_string()),
            vga: "std".to_string(),
            audio: vec![],
            network_model: "e1000".to_string(),
            disk_interface: "ide".to_string(),
            enable_kvm: true,
            uefi: false,
            tpm: false,
            rtc_localtime: false,
            usb_tablet: true,
            display: "gtk".to_string(),
            gl_acceleration: false,
            extra_args: vec![],
        };

        let cmd = build_qemu_command(&config, "disk.qcow2", false, None);

        assert!(cmd.contains("qemu-system-x86_64"));
        assert!(cmd.contains("-enable-kvm"));
        assert!(cmd.contains("-m 2048M"));
        assert!(cmd.contains("-smp 2"));
        assert!(cmd.contains("-vga std"));
        assert!(cmd.contains("-display gtk"));
        assert!(cmd.contains("-device e1000"));
        assert!(cmd.contains("-usb"));
        assert!(cmd.contains("-device usb-tablet"));
    }

    #[test]
    fn test_build_qemu_command_with_cdrom() {
        let config = WizardQemuConfig::default();
        let cmd = build_qemu_command(&config, "disk.qcow2", true, None);

        assert!(cmd.contains("-drive file=\"$ISO\",media=cdrom"));
        assert!(cmd.contains("-boot d"));
    }

    #[test]
    fn test_build_qemu_command_with_audio() {
        let config = WizardQemuConfig {
            audio: vec!["intel-hda".to_string(), "hda-duplex".to_string()],
            ..Default::default()
        };

        let cmd = build_qemu_command(&config, "disk.qcow2", false, None);

        assert!(cmd.contains("-audiodev pa,id=audio0"));
        assert!(cmd.contains("-device intel-hda"));
        assert!(cmd.contains("-device hda-duplex,audiodev=audio0"));
    }
}
